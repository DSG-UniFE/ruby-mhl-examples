#!/usr/bin/env ruby

begin
  require 'forwardable'
  require 'mhl'
  require 'logger'
  require 'pycall'
  require 'pycall/import'
  include PyCall::Import
rescue LoadError
  require 'rubygems'
  require 'mhl'
  require 'logger'
end

TIME = Time.now.strftime('%Y%m%d%H%M%S')
RESULTDIR = "#{TIME}_results"

# create an output directory if it does not exist
def create_log(method) 
  Dir.mkdir(RESULTDIR) unless File.exist?(RESULTDIR)
  log = "#{RESULTDIR}/#{method}_#{TIME}.log"
  File.delete(log) if File.exist?(log)
  logger = Logger.new(log)
  logger.level = Logger::DEBUG
  logger
end  

rastrigin = lambda do |x|
  d = x.length
  ret = 10 * d
  x.each do |xi|
    ret += xi ** 2 - 10 * Math::cos(2* Math::PI * xi)
  end
  ret
end

puts "--- Rastrigin Funcion Benchmark ---"
puts "--- n=2 xi in [-5.12, 5.12] ---"


logger = create_log("ga")
iteration = 100

solver_conf = {
    population_size: 128,
    genotype_space_type: :real, #binary o bitstrings (github)
    mutation_probability: 0.5,
    recombination_probability: 0.5,
    recombination_threshold: 0.40,
    genotype_space_conf: {
        dimensions: 2,
        recombination_type: :intermediate,
        random_func: lambda { Array.new(2) { rand(-5.12..5.12) } }, #array casuale con valori tra 0 e 1
        constraints: Array.new(2){{from: -5.12, to: 5.12}}
    },
  exit_condition: lambda {|gen, best| gen >= iteration  },
  logger: logger,
  log_level: :info
}
solver = MHL::GeneticAlgorithmSolver.new(solver_conf)

start = Time.now
best = solver.solve(rastrigin, {concurrent: false})
t_bench = Time.now - start

puts "GA: Population Size: 128, Iteration #{iteration}\n\t Best: #{best[:fitness]}, Time: #{t_bench}"

bests_ga = solver.best_positions

logger = create_log("qpso")
iteration = 100
solver_conf = {
  #num_swarms: 3,
  swarm_size: 40,
  logger: logger,
  constraints: {
    min: [-5.12,-5.12],
    max: [5.12, 5.12],
  },
  exit_condition: lambda {|gen, best| gen >= iteration  },
  log_level: :info
}

solver = MHL::QuantumPSOSolver.new(solver_conf)


start = Time.now
best = solver.solve(rastrigin, {concurrent: false})
t_bench = Time.now - start

puts "QPSO: Swarm_size: 40, Iteration #{iteration}\n\t Best: #{best[:height]}, Time: #{t_bench}"

bests_qpso = solver.best_positions

logger = create_log("MPSO")
iteration = 50

solver_conf = {
  num_swarms: 4,
  swarm_size: 50,
  logger: logger,
  constraints: {
    min: [-5.12,-5.12],
    max: [5.12, 5.12],
  },
  exit_condition: lambda {|gen, best| gen >= iteration  },
  log_level: :info
}

solver = MHL::MultiSwarmQPSOSolver.new(solver_conf)

start = Time.now
best = solver.solve(rastrigin, {concurrent: false})
t_bench = Time.now - start

puts "MPSO: Swarm_size: 50, N_Swarms: 4, Iteration #{iteration}\n\t Best: #{best[:height]}, Time: #{t_bench}"
bests_mpso = solver.best_positions

require 'matplotlib/pyplot'
plt = Matplotlib::Pyplot

X_LIMIT = 20

markers = [',', '+', '.', 'o', '*']

plt.plot((1..X_LIMIT).to_a, bests_ga.first(X_LIMIT), label: "GA", marker: markers[0])
plt.plot((1..X_LIMIT).to_a, bests_qpso.first(X_LIMIT), label: "QPSO", marker: markers[1])
plt.plot((1..X_LIMIT).to_a, bests_mpso.first(X_LIMIT), label: "MPSO", marker: markers[2])

plt.legend()
plt.xlabel('Iterations')
plt.ylabel('f(x)')
plt.title('Rastring Benchamrk')
plt.grid()
plt.savefig('rastring-bench.png')
plt.show()


exit 0
